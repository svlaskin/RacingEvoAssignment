#!/usr/bin/env python3# -*- coding: utf-8 -*-"""@author: SashaThis is the main file for the evolutionary algorithm. it encompasses both thetime simulation and evolutionary algorithm in its entirety."""## Imports hereimport pandas as pdimport matplotlib.pyplot as pltimport numpy as npfrom TrackLoad import *from AgentEvo import *import shapely.geometry as geomimport time as perftimerfrom time import perf_counterfrom random import seedfrom random import randomfrom random import randintimport pandas as pd"""------------------ Import Track Data ------------------------------------------"""# Path to track .csv filefpath_tracks = "/Users/Sasha/Desktop/Racing Line Optimisation Assignment/Racetrack_db/tracks"# Zandvoortexample_track = "/Users/Sasha/Desktop/Racing Line Optimisation Assignment/Racetrack_db/tracks/Zandvoort.csv"zandvoort_db = pd.read_csv(example_track) # read file# Import track geometry (centerline and boundaries)x_c, y_c, x_l, y_l, x_r, y_r, hdg_nxt, w_l, w_r = track_process(zandvoort_db)# Make coordinate sets out of centerline, left and right boundsleft_curve = list(zip(x_l,y_l))right_curve = list(zip(x_r,y_r))center_curve = list(zip(x_c,y_c))# Convert to shapely objects (for distance computation)center_line = geom.LineString(center_curve)left_line = geom.LineString(left_curve)right_line = geom.LineString(right_curve)"""------------ Agent Constants Definition ---------------------------------------Here, the constants (such as the car mass) will be defined"""# Car agent constants - assuming the lateral grip of a GT3 carvmax = 60 # max speed, [m/s]max_lat_g = 12 # 1.24 g (12 m/sÂ²)# Assumed values# Car agent initial conditionssteer_angle = 0.max_steer_angle = 600# time sim parameter dtdt = 0.01 # [s]run_step_1 = True # to rerun next steps without the first stepif run_step_1:    """    ---------------- Evolutionary Algorithm Parameters: Step 1 --------------------    Here, the parameters defining the first gen of the evolutionary algorithm    """    # Genome is defined as follows: [steer_const, dis2center_tol, heading_delta_tol, future2add, indfuture, acc_const]    example_genome = [0.3, 2, 50, 8, 0, 0.7]        # Generate random set of agents with randomized genomes,    n_candidates_start = 100 # number of agents in first step    genome_list = [] # empty list        for i in range(n_candidates_start): # loop through         steer_const_r = random() # steer constant can be between 0 and 1        dis2center_tol_r = random_scaled(0,4,random())         heading_delta_tol_r = random_scaled(0,90,random())        future2add_r = randint(0, 15)        indfuture_r = randint(0, 15)        acc_const_r = random_scaled(0,1,random())        genome_list.append([steer_const_r, dis2center_tol_r, heading_delta_tol_r, future2add_r, indfuture_r, acc_const_r])        # Empty arrays for run    lap_traces = []    lap_times = []    genomes_surv = []        """    ---------------- Evolutionary Algorithm - Step 1 ------------------------------    The first generation of the agents is generated here - this needs a separate    block of code as all of the agents have randomly generated genomes. After    this initial set is run and the best performing agents are kept and iterated upon    """        t_start = perftimer.perf_counter()    i=0    for genome in genome_list:        lap_trace = []        """------ Initial Conditions -----------------------------------------------"""        x_car, y_car = x_c[0], y_c[0] # Init position(on center of start line) [m]        heading_car = hdg_nxt[0] # Init heading [rad]        spd_car = 7 # inital speed [m/s], CURRENTLY LEFT CONSTANT        # vectorise this for later        pos_car = np.array([x_car,y_car])        v_car = np.array([spd_car*np.cos(heading_car),spd_car*np.sin(heading_car)])        finished = False # condition for car having completed the track        crashed = False # condition if car is out of track bounds        time_sim=0        i=i+1        print("doing ", i, " from ", np.shape(genome_list)[0])        while not finished and time_sim <800 and not crashed: # conditions for termination                        # add increment to time            time_sim += dt                        # Compute the "vision" components of the car agents, namely the distance to            # left and right walls and the itnersection point with the track ahead.            dis2wall_r = np.abs(geom.Point(pos_car).distance(right_line))            dis2wall_l = np.abs(geom.Point(pos_car).distance(left_line))            dis2centerline = np.abs(geom.Point(pos_car).distance(center_line))                        genome_current = genome                        # Feed current parameters into car to get velocity update            v_car, nearest_centerpoint, index_closest, spd_car, hdg_car = car_agent(v_car, pos_car, dis2wall_r, dis2wall_l, dis2centerline, center_curve, hdg_nxt, genome_current)                        # Compute next position with new velocity            pos_car = pos_car + v_car*dt            lap_trace.append(pos_car)                        # Car reaches finish line when the nearest point is the start/finish line point            if nearest_centerpoint == center_curve[0] and time_sim>50:                finished = True            # check if crashed: this happens when distance to centerline in either direction exceeds track width              if dis2centerline > w_r[index_closest]-0.1 or dis2centerline > w_l[index_closest]-0.1:                crashed=True        if not crashed:            lap_times.append(time_sim)            lap_traces.append(lap_trace)            genomes_surv.append(genome_current)            """    ----------- Plot Results and Telemetry  For Step 1  ---------------------------    """        t_end = perftimer.perf_counter()    print("total process time: ", t_end-t_start)        print("Fastest Run In: ", np.min(lap_times))       print("Number of Survivors: " , sum(1 for i in lap_times if i <999.))    index_fastest = np.where(lap_times==np.min(lap_times))[0][0]    lap_trace_fastest = lap_traces[index_fastest]     genome_fastest = genomes_surv[index_fastest]        plot_result(x_c, y_c, x_l, y_l, x_r, y_r, lap_trace_fastest)        # save first generation result as dataframe    # data_step1 = {"Genome": genomes_surv, "Laptime": lap_times,"Traces": lap_traces}    data_step1 = {"Genome": genomes_surv, "Laptime": lap_times}    gen1_dataframe = pd.DataFrame(data_step1)    gen1_dataframe.to_csv("gen1.csv")"""---------------- Evolutionary Algorithm Parameters: Step 2 --------------------The second step of the algorithm, that takes the outputs from the first randomly generated generation and runs an evolution process until each generation yields lessthan 1 second improvement in lap time"""# genomes_surv=genomes_survn_left = np.shape(genomes_surv)[0] # number of remaining candidates# n_left = 62# Some parameters necessary for the next steps of the evolutionary algorithmstop_diff = 5. # minimum time imporvement to warrant a future generationtime_prev = 999.time_best = np.min(lap_times) # the best (lowest) lap time from Gen1 in secondsbest_times_evo = [] # this array stores all of the best lap times by generationbest_genomes_evo = [] # list of best genomes per generationbest_times_evo.append(time_best)best_genomes_evo.append(genome_fastest)gen1_dataframe = gen1_dataframe.sort_values(by=['Laptime']) # sort dataframe by timeschromosomes_to_use = list(np.array(gen1_dataframe.Genome))n_agents = 40 # repoulate to this number using existing candidates"""------------- Evolution Alg. Main Loop  --------------------------------------This is the main loop for the evo alg. Here, new generations are generated and run until the termination criterion (max generation number).Ideally, this would run and terminate later but I only had access to a slowcomputer, so my apologies for this :)"""gen_number = 1while gen_number < 15:    gen_number = np.shape(best_times_evo)[0]+1 # number of the current generation    print("Running Generation #", gen_number)    time_prev = time_best # previous best lap time update       gen_number = gen_number+1        # Create New Agent Set    genome_neww = [] # update genome to last survivors            for i in range(n_agents+1): # how many extra agents needed        # Crossover here for new population        crossover_vals = [randint(0, 1) for _ in range(len(example_genome))] # decide which gene is kept from which agent randomly                # 2 agents that 'mate' to create new one        partner_1 = chromosomes_to_use[i%len(chromosomes_to_use)]        partner_2 = chromosomes_to_use[(i+1)%len(chromosomes_to_use)]                new_candidate = []        for i in range(len(crossover_vals)):            new_candidate.append(partner_1[i] if crossover_vals[i]==1 else partner_2[i])                # # Random mutation attempt: currently broken        # mutation_factor = [randint(0, 1) for _ in range(len(example_genome))]                 # steer_const_fac = random_scaled(0.9,1.1,random()) # steer constant can be between 0 and 1        # dis2center_tol_fac = random_scaled(0.9,1.1,random())        # heading_delta_tol_fac = random_scaled(0.9,1.1,random())        # future2add_fac = random_scaled(0.9,1.1,random())        # indfuture_fac = random_scaled(0.9,1.1,random())        # acc_const_fac = random_scaled(0.9,1.1,random())        # mutation_vec = np.array(mutation_factor)*np.array([steer_const_fac,dis2center_tol_fac,heading_delta_tol_fac,future2add_fac,indfuture_fac,acc_const_fac])        # genome_neww.append(list(np.array(new_candidate)*mutation_vec))                genome_neww.append(new_candidate)        """    ------------- Time Simulation  --------------------------------------------    Now that the new generation is ready, we run a time simulation    """    # Empty arrays for time sim run    lap_traces_evo = []    lap_times_evo = []    genomes_evo = []        # main simulation loop    t_start = perftimer.perf_counter()    i=0    for genome in genome_neww:        lap_trace = []        """------ Initial Conditions -----------------------------------------------"""        x_car, y_car = x_c[0], y_c[0] # Init position(on center of start line) [m]        heading_car = hdg_nxt[0] # Init heading [rad]        spd_car = 7 # inital speed [m/s], CURRENTLY LEFT CONSTANT        # vectorise this for later        pos_car = np.array([x_car,y_car])        v_car = np.array([spd_car*np.cos(heading_car),spd_car*np.sin(heading_car)])        finished = False # condition for car having completed the track        crashed = False # condition if car is out of track bounds        time_sim=0        i=i+1        print("doing ", i, " from ", np.shape(genome_neww)[0])        while not finished and time_sim <800 and not crashed: # conditions for termination                        # add increment to time            time_sim += dt                        # Compute the "vision" components of the car agents, namely the distance to            # left and right walls and the itnersection point with the track ahead.            dis2wall_r = np.abs(geom.Point(pos_car).distance(right_line))            dis2wall_l = np.abs(geom.Point(pos_car).distance(left_line))            dis2centerline = np.abs(geom.Point(pos_car).distance(center_line))                        genome_current = genome                        # Feed current parameters into car to get velocity update            v_car, nearest_centerpoint, index_closest, spd_car, hdg_car = car_agent(v_car, pos_car, dis2wall_r, dis2wall_l, dis2centerline, center_curve, hdg_nxt, genome_current)                        # Compute next position with new velocity            pos_car = pos_car + v_car*dt            lap_trace.append(pos_car)                        # Car reaches finish line when the nearest point is the start/finish line point            if nearest_centerpoint == center_curve[0] and time_sim>50:                finished = True            # check if crashed: this happens when distance to centerline in either direction exceeds track width              if dis2centerline > w_r[index_closest]-0.1 or dis2centerline > w_l[index_closest]-0.1:                crashed=True        if not crashed:            lap_times_evo.append(time_sim)            lap_traces_evo.append(lap_trace)            genomes_evo.append(genome_current)    """    ------------- Selection  --------------------------------------------------    The simulation is over and the lap times are known. We take only the top     10% to be used for the next generation. The best time value is also extracted    and the dataframe for the generation is saved.    """    t_end = perftimer.perf_counter()    print("Generation time: ", t_end-t_start)        index_fastest = np.where(lap_times_evo==np.min(lap_times_evo))[0][0]    # lap_trace_fastest = lap_traces[index_fastest]     genome_fastest = genomes_evo[index_fastest]    best_time_gen = np.min(lap_times_evo)        # plot_result(x_c, y_c, x_l, y_l, x_r, y_r, lap_trace_fastest)        # save first generation result as dataframe    data_step_evo = {"Genome": genomes_evo, "Laptime": lap_times_evo}    genX_dataframe = pd.DataFrame(data_step_evo)    name_df = "gen" + str(gen_number) + ".csv"    genX_dataframe.to_csv(name_df)        genX_dataframe = genX_dataframe.sort_values(by=['Laptime']) # sort by laptime        # filter only the top values for the next gen (within 10 percent of best)    genX_dataframe_top = genX_dataframe[genX_dataframe.Laptime<best_time_gen*1.1]    chromosomes_to_use = list(np.array(genX_dataframe_top.Genome))    n_left = len(chromosomes_to_use)    best_times_evo.append(best_time_gen)    best_genomes_evo.append(genome_fastest)    time_best = best_time_gen # update    """------------- Plot Fitness Function VS Gen -----------------------------------"""# plt.plot(999.-np.array(best_times_evo)) # fitness function# plt.xlabel("Generation")# plt.ylabel("Fitness [s]")# plt.grid()# plt.show()